---
title: "Custom Next.js Cache Handler を実際に活用してみて"
emoji: "🔄"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["nextjs", "react", "aws"]
published: false
---

:::message
この記事は [READYFOR Advent Calendar 2024](https://qiita.com/advent-calendar/2024/readyfor) の16日目の記事です。
:::

## はじめに

こんにちは、READYFOR のテックリード兼フロントエンドエンジニアの菅原（[@kotarella1110](https://twitter.com/kotarella1110)）です！
最近、Next.js App Router アプリケーションの実運用化に向けた PoC を実施しました。この中で、Next.js のキャッシュを永続ストレージに保存するために Custom Next.js Cache Handler を活用しました。
そこで本記事では、Custom Next.js Cache Handler の概要や実装時のポイント、注意点などを紹介したいと思います。

## PoC の概要

### 背景

READYFOR はクラウドファンディングのプラットフォームを運営しており、当初のフロントエンドアーキテクチャはモノリシックな Rails アプリケーションに [React on Rails](https://github.com/shakacode/react_on_rails) を組み込み、View 上で React コンポーネントレンダリングする構成でした。数年前、[フロントエンド分離戦略](https://tech.readyfor.jp/entry/2021/02/16/115311) を経て、一部の領域は Next.js Pages Router の Static Exports を使用した SPA へ移行されましたが、SSR が必要なページを含む未移行の領域では依然として React on Rails が使用されています。
今回、この未移行の領域を、様々な理由から Next.js App Router で SPA 化することを決定しました。
しかし、READYFOR では SSR が必要なページを含む SPA の構築・運用経験が無かったため、技術的な不確実性が高い状況でした。例えば、React on Rails は ExecJS を用いて SSR を行うので Node.js サーバーが不要でしたが、今回新たに Node.js サーバー（Next.js サーバー）の構築・運用が必要になります。
そこで、Next.js App Router アプリケーションの実運用化に向けた PoC を実施しました。

### インフラ構成

READYFOR では、主に AWS を活用してインフラを構築しています。そのため、今回の PoC でも既存のインフラとの親和性を重視し、Next.js をセルフホストする構成を採用しました。
Next.js サーバーは Amazon ECS を使用してデプロイし、Next.js キャッシュの保存先として Amazon ElastiCache for Redis を使用しています。

### パッケージのバージョン

本記事で取り上げるPoCで使用した主要なパッケージのバージョンは以下の通りです。これらのバージョンに基づいて解説を進めるため、最新のバージョンでは挙動や設定が異なる可能性がある点にご留意ください。

- Next.js: 14.2.15
- `@neshca/cache-handler`: 1.7.4

## セルフホスト環境における Next.js のキャッシュ

Next.js のキャッシュ（[Data Cache](https://nextjs.org/docs/app/building-your-application/caching#data-cache) 及び [Full Route Cache](https://nextjs.org/docs/app/building-your-application/caching#full-route-cache)）は、デフォルトでファイルシステム（ディスク）に保存されます。
しかし、セルフホスト環境において複数のインスタンスが稼働する分散環境が一般的であり、ファイルシステムキャッシュはインスタンス間で共有されません。このため、リクエストが異なるインスタンスにルーティングされると、キャッシュの不整合が発生してしまいます。
このキャッシュの一貫性を確保するためには、[Custom Next.js Cache Handler](https://nextjs.org/docs/app/api-reference/next-config-js/incrementalCacheHandlerPath) を利用し、Redis などの永続ストレージにキャッシュを保存するよう設定する必要があります。^[Vercel にデプロイする場合は、キャッシュは永続ストレージに自動的に保存されます。]

## Custom Next.js Cache Handler を利用したキャッシュの永続化例

Next.js の Cache Handler は、`get` / `set` / `revalidateTag` の3つのメソッドを含む[インターフェース](https://github.com/vercel/next.js/blob/v14.2.20/packages/next/src/server/lib/incremental-cache/index.ts#L47-L66)に沿ってクラスを実装する必要があります。
これらのメソッドに、Redis へのキャッシュの取得、保存、再検証の処理を自前で実装する必要があります。

https://nextjs.org/docs/app/building-your-application/deploying#configuring-caching

これらを実装するのは~~面倒~~大変なので、[公式の Custom Next.js Cache Handler の Example](https://github.com/vercel/next.js/blob/canary/examples/cache-handler-redis/cache-handler.js) でも使用されている [`@neshca/cache-handler`](https://caching-tools.github.io/next-shared-cache) というライブラリが非常に便利です。

`@neshca/cache-handler` を活用した実装例は以下の通りです。

```js:next.config.js
module.exports = {
  generateBuildId: () => process.env.GIT_HASH ?? null,
  cacheHandler: process.env.NODE_ENV === "production" ? require.resolve("./cache-handler.js") : undefined,
  cacheMaxMemorySize: 0, // disable default in-memory caching
};
```

```js:cache-handler.js
const { CacheHandler } = require("@neshca/cache-handler");
const createRedisHandler = require("@neshca/cache-handler/redis-strings").default;
const createLruHandler = require("@neshca/cache-handler/local-lru").default;
const { createClient } = require("redis");
const { PHASE_PRODUCTION_BUILD } = require("next/constants");
const Sentry = require("@sentry/nextjs");

CacheHandler.onCreation(async (context) => {
  let client;
  // Opt out the cache on build. https://github.com/caching-tools/next-shared-cache/issues/284
  if (PHASE_PRODUCTION_BUILD !== process.env.NEXT_PHASE) {
    try {
      // Create a Redis client.
      client = createClient({
        url: process.env.REDIS_URL ?? "redis://localhost:6379",
      });

      client.on("reconnecting", () => {
        console.warn(`Reconnecting to Redis server...`);
      });

      // Redis won't work without error handling. https://github.com/redis/node-redis?tab=readme-ov-file#events
      client.on("error", (e) => {
        Sentry.captureException(e);
        console.error("Redis error", e);
      });
    } catch (error) {
      Sentry.captureException(error);
      console.warn("Failed to create Redis client:", error);
    }
  }

  if (client) {
    try {
      console.info("Connecting Redis client...");

      // Wait for the client to connect.
      // Caveat: This will block the server from starting until the client is connected.
      // And there is no timeout. Make your own timeout if needed.
      await client.connect();
      console.info("Redis client connected.");
    } catch (error) {
      Sentry.captureException(error);
      console.warn("Failed to connect Redis client:", error);
      console.warn("Disconnecting the Redis client...");
      // Try to disconnect the client to stop it from reconnecting.
      client
        .disconnect()
        .then(() => {
          console.info("Redis client disconnected.");
        })
        .catch(() => {
          console.warn(
            "Failed to quit the Redis client after failing to connect.",
          );
        });
    }
  }

  /** @type {import("@neshca/cache-handler").Handler | null} */
  let handler = null;
  if (client?.isReady) {
    // Create the Redis Handler if the client is available and connected.
    handler = await createRedisHandler({
      client,
      keyPrefix: `${context.buildId ?? "prefix"}:`,
      timeoutMs: 1000,
    });
  } else {
    // Fallback to LRU handler if Redis client is not available.
    // The application will still work, but the cache will be in memory only and not shared.
    handler = createLruHandler();
    console.warn(
      "Falling back to LRU handler because Redis client is not available.",
    );
  }

  return {
    handlers: [handler],
    ttl: {
      estimateExpireAge: (staleAge) => staleAge,
    },
  };
});

module.exports = CacheHandler;
```

## 実装例のポイント

### ビルドフェーズ Redis Client を作成しない

TODO

### ビルド毎に異なるキャッシュを利用する

ハンドラーのオプションで [`keyPrefix`](https://caching-tools.github.io/next-shared-cache/handlers/redis-strings#parameters) を指定することで、Redis に保存されるキャッシュキーにプレフィックスを付与できます。

実装例では、`context` から Next.js の現在のビルドに対応する `buildId` を取得することができるため、この `buildId` を `keyPrefix`に指定することで、ビルド毎に異なるプレフィックスが付与されるようにしています。これにより、ビルド間でキャッシュが共有されなくなるため、デプロイ毎にキャッシュが作り直されるようになります。

```js:cache-handler.js
CacheHandler.onCreation(async (context) => {
  // ...
  handler = await createRedisHandler({
    client,
    keyPrefix: `${context.buildId ?? "prefix"}:`,
    timeoutMs: 1000,
  });
  // ...
});
```

逆に、`keyPrefix` を指定しない（もしくは、固定文字列を指定する）場合は、ビルド間でキャッシュが再利用されるようになります。キャッシュの再計算コストを抑えたい場合は、この方法も有効だと思います。

### TTL パラメーターを指定する

Next.js の [Time-based Revalidation](https://nextjs.org/docs/app/building-your-application/caching#time-based-revalidation) は、`next.revalidate` オプション等に指定したキャッシュの有効期間の間隔でデータを再検証するための機能です。以下の場合だと5秒間隔でデータを再検証します。

```js
fetch("https://...", { next: { revalidate: 5 } });
```

この Time-based Revalidation が、**`@neshca/cache-handler` の [TTL パラメーター](https://caching-tools.github.io/next-shared-cache/api-reference/ttl-parameters)がデフォルトのまま**だと、[Next.js の標準的な挙動](https://nextjs.org/docs/app/building-your-application/caching#time-based-revalidation)と異なる挙動になります。

Next.js 標準の Time-based Revalidation では、以下の図のように、キャッシュの有効期間が経過した後の最初のリクエストに対してキャッシュされた `STALE` なデータが返され、バックグラウンドでデータの再検証（`Revalidation`）が行われた後にキャッシュを更新（`SET`）します。

![Time-based Revalidation がどのように機能するかを示す図](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Ftime-based-revalidation.png&w=1920&q=75)

一方、`@neshca/cache-handler` では、TTL パラメーターがデフォルトのままだと、有効期間が経過するとキャッシュ自体が削除されます。これは、キャッシュの有効期間が Redis キャッシュの TTL として設定され、キャッシュの期限切れとして削除されるためです。そのため、キャッシュの有効期間が過ぎた後の最初のリクエストではキャッシュが存在しない（`MISS`）ため、最新のデータが取得してキャッシュを更新（`SET`）します。

これを Next.js 標準の Time-based Revalidation と同じような挙動にするためには、TTL パラメーターの`estimateExpireAge` オプションを指定して、キャッシュの期限切れ期間をキャッシュの有効期間よりも長く設定する必要があります。
例えば、以下のようにキャッシュの有効期間を5秒にして、`estimateExpireAge` で返す値を有効期間の3倍にすると、期限切れの期間が15秒になります。つまり、5秒経過した後の「5秒〜15秒」の間に最初のリクエストがあれば `STALE` なデータが返され、バックグラウンドでデータの再検証されるようになります。当然、15秒経過した後には期限切れのためキャッシュが削除されます。

```js
fetch("https://...", { next: { revalidate: 5 } });
```

```js:cache-handler.js
CacheHandler.onCreation(async () => {
  // ...
  handlers: [handler],
    ttl: {
      estimateExpireAge: (staleAge) => staleAge * 3,
    },
});
```

補足として、`@neshca/cache-handler` のバージョン 1.9.0 からは `estimateExpireAge` のデフォルトが `(staleAge) => staleAge` から `(staleAge) => staleAge * 1.5` になりました。これにより、TTL パラメーターがデフォルトのままでも、Next.js 標準の Time-based Revalidation の挙動と同じようになりました。

https://github.com/caching-tools/next-shared-cache/issues/828

ただし、デフォルトでは、キャッシュの期限切れ期間がキャッシュの有効期間の1.5倍なので、`STALE` なデータが返される期間が比較的短めです。
そのため、`estimateExpireAge` の適切な値を検討して設定することが重要です。

### Sentry でエラーをトラッキングする

TODO

## 注意点

### Redis モジュールが使用できない環境では `redis-stack` は使用できない

Next.js のキャッシュ周りの検証中に [`redis-stack` ハンドラー](https://caching-tools.github.io/next-shared-cache/handlers/redis-stack)を使用していましたが、AWS 環境にデプロイした際、以下の箇所でエラーが発生しました。Redis サーバーとして Amazon ElastiCache for Redis を使用しています。

https://github.com/caching-tools/next-shared-cache/blob/88010c21bb7f4a3680cc571cf500cb01747408f9/packages/cache-handler/src/handlers/redis-stack.ts#L58-L67

```
Error: ERR unknown command 'FT.CREATE', with args beginning with: 'idx:tags-xxxxx' 'ON' 'JSON' 'TEMPORARY' '31536000' 'SCHEMA' '$.tags'
```

このエラーは、[`FT.CREATE`](https://redis.io/docs/latest/commands/ft.create/) コマンドが [RedisSearch](https://redis.io/docs/latest/develop/interact/search-and-query/) モジュールを必要とするために発生します。`redis-stack` ハンドラーは `RedisJSON` と `RedisSearch` モジュールを使用しますが、これらのモジュールは Redis Ltd. によって開発され、[ライセンス](https://redis.io/legal/licenses/)の制約によりクラウドプロバイダーが提供する多くのマネージド Redis サービスではサポートされていません。Amazon ElastiCache for Redis もこれに該当します。

そのため、Redis モジュールが使用できない環境では [`redis-strings` ハンドラー](https://caching-tools.github.io/next-shared-cache/handlers/redis-strings)を使用する必要があります。このハンドラーは Redis の基本機能のみを利用し、モジュールへの依存がないため幅広い環境で動作します。

### Pre-rendering が完全に無駄になる

TODO

### `@neshca/cache-handler` は Next.js v15 をサポートしていない

自分の方で確認した際、@neshca/cache-handler は Next.js v15 をサポートしておらず、On-demand Revalidation API が正常に動作しない状況でした。
そのため、Next.js v15 を使用する場合、以下の PR で対応が進められている正式なサポートのリリースを待つ必要があります。

https://github.com/caching-tools/next-shared-cache/pull/846
